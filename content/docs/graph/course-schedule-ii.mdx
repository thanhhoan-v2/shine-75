---
title: Course Schedule II
description: There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.
difficulty: Medium
timeLimit: 35 mins
week: 2
tags:
  - Graph
---

```js title="Example"
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,1,2,3]
Explanation: One valid course order is [0,1,2,3]. Another valid course order is [0,2,1,3].
```

## Approach

1. **Build Graph**: Create an adjacency list representation of the course dependencies
2. **Calculate In-Degrees**: Count the number of prerequisites for each course
3. **Topological Sort**: Use Kahn's algorithm to perform topological sorting
4. **Queue Initialization**: Add all courses with 0 prerequisites to the queue
5. **Process Queue**: For each course, reduce in-degree of its dependent courses
6. **Return Result**: Return the topological order or empty array if cycle exists

## Solution

- Time Complexity: `O(n + m)`
  > Where n is number of courses and m is number of prerequisites
- Space Complexity: `O(n + m)`
  > We store the graph and in-degree counts

```js tab="JavaScript"
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function(numCourses, prerequisites) {
    const graph = Array(numCourses).fill().map(() => []);
    const inDegree = Array(numCourses).fill(0);
    
    // Build graph and calculate in-degrees
    for (const [course, prereq] of prerequisites) {
        graph[prereq].push(course);
        inDegree[course]++;
    }
    
    // Topological sort
    const queue = [];
    const result = [];
    
    // Add courses with 0 prerequisites
    for (let i = 0; i < numCourses; i++) {
        if (inDegree[i] === 0) {
            queue.push(i);
        }
    }
    
    while (queue.length > 0) {
        const course = queue.shift();
        result.push(course);
        
        // Reduce in-degree of dependent courses
        for (const dependent of graph[course]) {
            inDegree[dependent]--;
            if (inDegree[dependent] === 0) {
                queue.push(dependent);
            }
        }
    }
    
    // Check if all courses can be taken
    return result.length === numCourses ? result : [];
};
```

```java tab="Java"
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<List<Integer>> graph = new ArrayList<>();
        int[] inDegree = new int[numCourses];
        
        // Initialize graph
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }
        
        // Build graph and calculate in-degrees
        for (int[] prereq : prerequisites) {
            int course = prereq[0];
            int prereqCourse = prereq[1];
            graph.get(prereqCourse).add(course);
            inDegree[course]++;
        }
        
        // Topological sort
        Queue<Integer> queue = new LinkedList<>();
        List<Integer> result = new ArrayList<>();
        
        // Add courses with 0 prerequisites
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        while (!queue.isEmpty()) {
            int course = queue.poll();
            result.add(course);
            
            // Reduce in-degree of dependent courses
            for (int dependent : graph.get(course)) {
                inDegree[dependent]--;
                if (inDegree[dependent] == 0) {
                    queue.offer(dependent);
                }
            }
        }
        
        // Check if all courses can be taken
        if (result.size() != numCourses) {
            return new int[0];
        }
        
        return result.stream().mapToInt(Integer::intValue).toArray();
    }
}
```
