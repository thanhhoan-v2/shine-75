---
title: Meeting Rooms II
description: Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.
difficulty: Medium
timeLimit: 25 mins
week: 3
tags:
  - Array
  - Sorting
  - Heap
  - Greedy
---

```js title="Example"
Input: intervals = [[0, 30], [5, 10], [15, 20]]
Output: 2
Explanation: We need two conference rooms: room 1 for [0, 30] and room 2 for [5, 10] and [15, 20].

Input: intervals = [[7, 10], [2, 4]]
Output: 1
```

## Approach

1. **Sort Start and End Times**: Sort all start and end times separately.
2. **Two Pointers**: Use two pointers to track start and end times.
3. **Increment on Start**: When we encounter a start time, increment room count.
4. **Decrement on End**: When we encounter an end time, decrement room count.
5. **Track Maximum**: Keep track of the maximum number of rooms needed.

## Solution

- Time Complexity: `O(n log n)`
  > Where n is the number of intervals. We need to sort the start and end times, which takes O(n log n).
- Space Complexity: `O(n)`
  > We create arrays to store start and end times.

```js tab="JavaScript"
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var minMeetingRooms = function(intervals) {
    const starts = intervals.map(interval => interval[0]).sort((a, b) => a - b);
    const ends = intervals.map(interval => interval[1]).sort((a, b) => a - b);
    
    let rooms = 0;
    let maxRooms = 0;
    let startIndex = 0;
    let endIndex = 0;
    
    while (startIndex < starts.length) {
        if (starts[startIndex] < ends[endIndex]) {
            rooms++;
            maxRooms = Math.max(maxRooms, rooms);
            startIndex++;
        } else {
            rooms--;
            endIndex++;
        }
    }
    
    return maxRooms;
};
```

```java tab="Java"
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        int[] starts = new int[intervals.length];
        int[] ends = new int[intervals.length];
        
        for (int i = 0; i < intervals.length; i++) {
            starts[i] = intervals[i][0];
            ends[i] = intervals[i][1];
        }
        
        Arrays.sort(starts);
        Arrays.sort(ends);
        
        int rooms = 0;
        int maxRooms = 0;
        int startIndex = 0;
        int endIndex = 0;
        
        while (startIndex < starts.length) {
            if (starts[startIndex] < ends[endIndex]) {
                rooms++;
                maxRooms = Math.max(maxRooms, rooms);
                startIndex++;
            } else {
                rooms--;
                endIndex++;
            }
        }
        
        return maxRooms;
    }
}
```
