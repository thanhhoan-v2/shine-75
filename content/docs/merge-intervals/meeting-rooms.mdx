---
title: Meeting Rooms
description: Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.
difficulty: Easy
timeLimit: 20 mins
week: 1
tags:
  - Array
  - Sorting
  - Merge Intervals
---

```js title="Example"
Input: intervals = [[0,30],[5,10],[15,20]]
Output: false
Explanation: There are overlapping meetings: [0,30] overlaps with [5,10] and [15,20].

Input: intervals = [[7,10],[2,4]]
Output: true
Explanation: No overlapping meetings.
```

## Approach

1. **Sort Intervals**: Sort intervals by start time
2. **Check Adjacent**: Compare each interval with the next one
3. **Overlap Detection**: Check if current interval's end time overlaps with next interval's start time
4. **Return Result**: Return false if any overlap is found, true otherwise

## Solution

- Time Complexity: `O(n log n)`
  > We need to sort the intervals
- Space Complexity: `O(1)`
  > We only use a constant amount of extra space

```js tab="JavaScript"
/**
 * @param {number[][]} intervals
 * @return {boolean}
 */
var canAttendMeetings = function(intervals) {
    if (intervals.length <= 1) return true;
    
    // Sort intervals by start time
    intervals.sort((a, b) => a[0] - b[0]);
    
    // Check for overlaps
    for (let i = 0; i < intervals.length - 1; i++) {
        if (intervals[i][1] > intervals[i + 1][0]) {
            return false;
        }
    }
    
    return true;
};
```

```java tab="Java"
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        if (intervals.length <= 1) return true;
        
        // Sort intervals by start time
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        
        // Check for overlaps
        for (int i = 0; i < intervals.length - 1; i++) {
            if (intervals[i][1] > intervals[i + 1][0]) {
                return false;
            }
        }
        
        return true;
    }
}
```
