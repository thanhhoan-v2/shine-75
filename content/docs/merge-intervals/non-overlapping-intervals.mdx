---
title: Non-overlapping Intervals
description: Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
difficulty: Medium
timeLimit: 25 mins
week: 3
tags:
  - Array
  - Sorting
  - Greedy
---

```js title="Example"
Input: intervals = [[1, 2], [2, 3], [3, 4], [1, 3]]
Output: 1
Explanation: [1, 3] can be removed and the rest of the intervals are non-overlapping.

Input: intervals = [[1, 2], [1, 2], [1, 2]]
Output: 2
Explanation: You need to remove two [1, 2] to make the rest non-overlapping.
```

## Approach

1. **Sort by End Time**: Sort intervals by end time (ascending).
2. **Track Last End**: Keep track of the end time of the last selected interval.
3. **Greedy Selection**: For each interval:
   - If it starts after or at the end of the last selected interval, keep it.
   - Otherwise, remove it (increment count).
4. **Return Count**: Return the count of removed intervals.
5. **Optimal Strategy**: Always keep the interval with the earliest end time.

## Solution

- Time Complexity: `O(n log n)`
  > Where n is the number of intervals. We need to sort the intervals, which takes O(n log n).
- Space Complexity: `O(1)`
  > We only use a constant amount of extra space for variables.

```js tab="JavaScript"
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function(intervals) {
    if (intervals.length === 0) return 0;
    
    intervals.sort((a, b) => a[1] - b[1]);
    
    let count = 0;
    let end = intervals[0][1];
    
    for (let i = 1; i < intervals.length; i++) {
        if (intervals[i][0] >= end) {
            end = intervals[i][1];
        } else {
            count++;
        }
    }
    
    return count;
};
```

```java tab="Java"
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) return 0;
        
        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
        
        int count = 0;
        int end = intervals[0][1];
        
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] >= end) {
                end = intervals[i][1];
            } else {
                count++;
            }
        }
        
        return count;
    }
}
```
