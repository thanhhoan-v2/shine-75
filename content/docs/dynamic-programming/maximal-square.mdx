---
title: Maximal Square
description: Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.
difficulty: Medium
timeLimit: 30 mins
week: 3
tags:
  - Dynamic Programming
---

```js title="Example"
Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 4
Explanation: The largest square has side length 2.
```

## Approach

1. **Dynamic Programming Matrix**: Create a dp matrix where dp[i][j] represents the side length of the largest square ending at (i,j)
2. **Initialize**: Copy the first row and first column from the input matrix
3. **Fill DP Matrix**: For each cell (i,j), if matrix[i][j] is '1', set dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
4. **Track Maximum**: Keep track of the maximum side length found
5. **Return Result**: Return the square of the maximum side length

## Solution

- Time Complexity: `O(m*n)`
  > We iterate through each cell in the matrix once
- Space Complexity: `O(m*n)`
  > We use a dp matrix of size m*n

```js tab="JavaScript"
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function(matrix) {
    if (!matrix || matrix.length === 0) return 0;
    
    const m = matrix.length;
    const n = matrix[0].length;
    const dp = Array(m).fill().map(() => Array(n).fill(0));
    
    let maxSide = 0;
    
    // Fill first row
    for (let j = 0; j < n; j++) {
        dp[0][j] = parseInt(matrix[0][j]);
        maxSide = Math.max(maxSide, dp[0][j]);
    }
    
    // Fill first column
    for (let i = 0; i < m; i++) {
        dp[i][0] = parseInt(matrix[i][0]);
        maxSide = Math.max(maxSide, dp[i][0]);
    }
    
    // Fill rest of the matrix
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            if (matrix[i][j] === '1') {
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1;
                maxSide = Math.max(maxSide, dp[i][j]);
            }
        }
    }
    
    return maxSide * maxSide;
};
```

```java tab="Java"
class Solution {
    public int maximalSquare(char[][] matrix) {
        if (matrix == null || matrix.length == 0) return 0;
        
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] dp = new int[m][n];
        
        int maxSide = 0;
        
        // Fill first row
        for (int j = 0; j < n; j++) {
            dp[0][j] = matrix[0][j] - '0';
            maxSide = Math.max(maxSide, dp[0][j]);
        }
        
        // Fill first column
        for (int i = 0; i < m; i++) {
            dp[i][0] = matrix[i][0] - '0';
            maxSide = Math.max(maxSide, dp[i][0]);
        }
        
        // Fill rest of the matrix
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == '1') {
                    dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + 1;
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
            }
        }
        
        return maxSide * maxSide;
    }
}
```
