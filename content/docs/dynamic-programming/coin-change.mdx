---
title: Coin Change
description: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount.
difficulty: Medium
timeLimit: 25 mins
week: 1
tags:
  - Dynamic Programming
---

```js title="Example"
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
```

## Approach

1. **Dynamic Programming Array**: Create a dp array where dp[i] represents the minimum number of coins needed for amount i
2. **Initialize**: Set dp[0] = 0 and all other values to Infinity
3. **Bottom-up Approach**: For each amount from 1 to target, try each coin denomination
4. **Update Minimum**: For each coin, if it can be used, update dp[amount] with the minimum of current value and 1 + dp[amount - coin]
5. **Return Result**: Return dp[amount] if it's not Infinity, otherwise return -1

## Solution

- Time Complexity: `O(amount * len(coins))`
  > We iterate through each amount and for each amount, we try all coin denominations
- Space Complexity: `O(amount)`
  > We use a dp array of size amount + 1

```js tab="JavaScript"
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    const dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0;
    
    for (let i = 1; i <= amount; i++) {
        for (const coin of coins) {
            if (coin <= i) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] === Infinity ? -1 : dp[amount];
};
```

```java tab="Java"
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (coin <= i && dp[i - coin] != Integer.MAX_VALUE) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```
