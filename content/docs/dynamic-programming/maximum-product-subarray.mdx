---
title: Maximum Product Subarray
description: Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.
difficulty: Medium
timeLimit: 30 mins
week: 2
tags:
  - Dynamic Programming
---

```js title="Example"
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
```

## Approach

1. **Track Maximum and Minimum**: Keep track of both maximum and minimum product ending at current position
2. **Handle Negative Numbers**: When we encounter a negative number, the maximum becomes minimum and vice versa
3. **Update Products**: For each element, update max and min products considering the current element
4. **Track Global Maximum**: Keep track of the global maximum product found so far
5. **Return Result**: Return the global maximum

## Solution

- Time Complexity: `O(n)`
  > We iterate through the array once
- Space Complexity: `O(1)`
  > We only use a few variables regardless of input size

```js tab="JavaScript"
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    if (nums.length === 0) return 0;
    
    let maxSoFar = nums[0];
    let maxEndingHere = nums[0];
    let minEndingHere = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        const temp = maxEndingHere;
        maxEndingHere = Math.max(nums[i], Math.max(maxEndingHere * nums[i], minEndingHere * nums[i]));
        minEndingHere = Math.min(nums[i], Math.min(temp * nums[i], minEndingHere * nums[i]));
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }
    
    return maxSoFar;
};
```

```java tab="Java"
class Solution {
    public int maxProduct(int[] nums) {
        if (nums.length == 0) return 0;
        
        int maxSoFar = nums[0];
        int maxEndingHere = nums[0];
        int minEndingHere = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            int temp = maxEndingHere;
            maxEndingHere = Math.max(nums[i], Math.max(maxEndingHere * nums[i], minEndingHere * nums[i]));
            minEndingHere = Math.min(nums[i], Math.min(temp * nums[i], minEndingHere * nums[i]));
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }
}
```
