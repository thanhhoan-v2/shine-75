---
title: Combination Sum IV
description: Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.
difficulty: Medium
timeLimit: 35 mins
week: 3
tags:
  - Dynamic Programming
---

```js title="Example"
Input: nums = [1,2,3], target = 4
Output: 7
Explanation: The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
```

## Approach

1. **Dynamic Programming Array**: Create a dp array where dp[i] represents the number of combinations that sum to i
2. **Initialize**: Set dp[0] = 1 (one way to make sum 0 - empty combination)
3. **Bottom-up Approach**: For each target from 1 to target, try each number in nums
4. **Update Combinations**: For each number, if it can be used, add dp[target - num] to dp[target]
5. **Return Result**: Return dp[target]

## Solution

- Time Complexity: `O(target * len(nums))`
  > We iterate through each target value and for each target, we try all numbers in nums
- Space Complexity: `O(target)`
  > We use a dp array of size target + 1

```js tab="JavaScript"
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var combinationSum4 = function(nums, target) {
    const dp = new Array(target + 1).fill(0);
    dp[0] = 1;
    
    for (let i = 1; i <= target; i++) {
        for (const num of nums) {
            if (num <= i) {
                dp[i] += dp[i - num];
            }
        }
    }
    
    return dp[target];
};
```

```java tab="Java"
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        
        for (int i = 1; i <= target; i++) {
            for (int num : nums) {
                if (num <= i) {
                    dp[i] += dp[i - num];
                }
            }
        }
        
        return dp[target];
    }
}
```
