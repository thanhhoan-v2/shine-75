---
title: Easy Problems
description: A curated collection of easy difficulty algorithmic problems organized by pattern and technique
icon: Brain
---

# Easy Problems Collection

This section contains a carefully curated selection of easy difficulty algorithmic problems, organized by their underlying patterns and techniques. These problems are perfect for beginners and serve as excellent building blocks for more complex algorithmic challenges.

## Two Pointers Technique

Problems that use two pointers to efficiently solve array and string challenges:

- [Two Sum](/docs/two-pointers/two-sum) - Find two numbers that add up to a target
- [Valid Palindrome](/docs/two-pointers/valid-palindrome) - Check if a string is a valid palindrome
- [Move Zeroes](/docs/two-pointers/move-zeroes) - Move all zeros to the end while maintaining order
- [Squares of a Sorted Array](/docs/two-pointers/squares-of-a-sorted-array) - Square each element and return sorted result

## Fast & Slow Pointers

Linked list problems using the tortoise and hare technique:

- [Linked List Cycle](/docs/fast-slow-pointers/linked-list-cycle) - Detect if a linked list has a cycle
- [Middle of the Linked List](/docs/fast-slow-pointers/middle-of-the-linked-list) - Find the middle node of a linked list
- [Palindrome Linked List](/docs/fast-slow-pointers/palindrome-linked-list) - Check if a linked list is a palindrome

## Sliding Window

Problems that use a sliding window to efficiently process subarrays:

- [Best Time to Buy and Sell Stock](/docs/sliding-window/best-time-to-buy-and-sell-stock) - Find maximum profit from buying and selling stock

## Tree Traversal

Binary tree problems covering various traversal techniques:

- [Invert Binary Tree](/docs/tree-traversal/invert-binary-tree) - Mirror a binary tree
- [Balanced Binary Tree](/docs/tree-traversal/balanced-binary-tree) - Check if a tree is height-balanced
- [Diameter of Binary Tree](/docs/tree-traversal/diameter-of-binary-tree) - Find the longest path between any two nodes
- [Maximum Depth of Binary Tree](/docs/tree-traversal/maximum-depth-of-binary-tree) - Find the height of a binary tree
- [Same Tree](/docs/tree-traversal/same-tree) - Check if two binary trees are identical
- [Symmetric Tree](/docs/tree-traversal/symmetric-tree) - Check if a tree is symmetric around its center
- [Subtree of Another Tree](/docs/tree-traversal/subtree-of-another-tree) - Check if one tree is a subtree of another
- [Lowest Common Ancestor of a Binary Search Tree](/docs/tree-traversal/lowest-common-ancestor-of-a-binary-search-tree) - Find the LCA in a BST
- [Convert Sorted Array to Binary Search Tree](/docs/tree-traversal/convert-sorted-array-to-binary-search-tree) - Build a balanced BST from sorted array

## Graph Traversal (BFS/DFS)

Graph problems using breadth-first and depth-first search:

- [Flood Fill](/docs/graph-traversal/flood-fill) - Fill connected pixels with a new color

## Merge Intervals

Problems involving interval manipulation and merging:

- [Meeting Rooms](/docs/merge-intervals/meeting-rooms) - Check if a person can attend all meetings

## Cyclic Sort

Problems that use cyclic sort for arrays with specific properties:

- [Contains Duplicate](/docs/cyclic-sort/contains-duplicate) - Check if an array contains duplicates
- [Missing Number](/docs/cyclic-sort/missing-number) - Find the missing number in a sequence

## Bit Manipulation

Problems that leverage bitwise operations:

- [Add Binary](/docs/bit-manipulation/add-binary) - Add two binary strings
- [Counting Bits](/docs/bit-manipulation/counting-bits) - Count the number of 1 bits for each number
- [Number of 1 Bits](/docs/bit-manipulation/number-of-1-bits) - Count the number of 1 bits in an integer
- [Reverse Bits](/docs/bit-manipulation/reverse-bits) - Reverse the bits of a 32-bit integer
- [Single Number](/docs/bit-manipulation/single-number) - Find the single number that appears once

## Hash Table

Problems that efficiently use hash tables for lookups:

- [Valid Anagram](/docs/hash-table/valid-anagram) - Check if two strings are anagrams

---

## Getting Started

Start with the **Two Pointers** section if you're new to algorithms, as these problems introduce fundamental concepts. Each problem includes:

- Detailed problem description
- Multiple solution approaches
- Time and space complexity analysis
- Step-by-step explanations
- Practice exercises

Choose problems based on the patterns you want to master or work through them systematically to build a strong algorithmic foundation.