---
title: Binary Search
description: Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
difficulty: Easy
timeLimit: 15 mins
week: 1
tags:
  - Binary Search
  - Array
---

```js title="Example"
Input: nums = [-1, 0, 3, 5, 9, 12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4.

Input: nums = [-1, 0, 3, 5, 9, 12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1.
```

## Approach

1. **Initialize Pointers**: Set left pointer to 0 and right pointer to array length - 1.
2. **Calculate Midpoint**: Calculate mid = left + (right - left) / 2 to avoid overflow.
3. **Compare Target**: Compare target with nums[mid].
4. **Update Pointers**: If target < nums[mid], move right to mid - 1. If target > nums[mid], move left to mid + 1.
5. **Return Result**: If target == nums[mid], return mid. If left > right, return -1.

## Solution

- Time Complexity: `O(log n)`
  > Where n is the length of the array. Each iteration reduces the search space by half.
- Space Complexity: `O(1)`
  > We only use a constant amount of extra space for variables.

```js tab="JavaScript"
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        
        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
};
```

```java tab="Java"
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;
    }
}
```
