---
title: Number of Connected Components in an Undirected Graph
description: You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.
difficulty: Medium
timeLimit: 30 mins
week: 3
tags:
  - Graph
---

```js title="Example"
Input: n = 5, edges = [[0,1],[1,2],[3,4]]
Output: 2
```

## Approach

1. **Union-Find Data Structure**: Use Union-Find to group connected nodes
2. **Initialize**: Create parent array where each node is its own parent initially
3. **Process Edges**: For each edge, union the two nodes
4. **Count Components**: Count the number of unique root nodes
5. **Return Result**: Return the count of connected components

## Solution

- Time Complexity: `O(n + m)`
  > Where n is number of nodes and m is number of edges
- Space Complexity: `O(n)`
  > We use parent array for Union-Find

```js tab="JavaScript"
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number}
 */
var countComponents = function(n, edges) {
    const parent = Array(n).fill().map((_, i) => i);
    
    const find = (x) => {
        if (parent[x] !== x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    };
    
    const union = (x, y) => {
        const px = find(x);
        const py = find(y);
        if (px !== py) {
            parent[px] = py;
        }
    };
    
    // Process all edges
    for (const [u, v] of edges) {
        union(u, v);
    }
    
    // Count unique roots
    const roots = new Set();
    for (let i = 0; i < n; i++) {
        roots.add(find(i));
    }
    
    return roots.size;
};
```

```java tab="Java"
class Solution {
    public int countComponents(int n, int[][] edges) {
        int[] parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            union(parent, u, v);
        }
        
        // Count unique roots
        Set<Integer> roots = new HashSet<>();
        for (int i = 0; i < n; i++) {
            roots.add(find(parent, i));
        }
        
        return roots.size();
    }
    
    private int find(int[] parent, int x) {
        if (parent[x] != x) {
            parent[x] = find(parent, parent[x]);
        }
        return parent[x];
    }
    
    private void union(int[] parent, int x, int y) {
        int px = find(parent, x);
        int py = find(parent, y);
        if (px != py) {
            parent[px] = py;
        }
    }
}
```
