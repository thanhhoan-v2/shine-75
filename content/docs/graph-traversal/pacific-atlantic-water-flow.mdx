---
title: Pacific Atlantic Water Flow
description: There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.
difficulty: Medium
timeLimit: 30 mins
week: 2
tags:
  - Graph
---

```js title="Example"
Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

## Approach

1. **Reverse DFS**: Start from ocean borders and work backwards to find reachable cells
2. **Two Passes**: One pass for Pacific Ocean (left and top borders), one for Atlantic (right and bottom borders)
3. **Height Comparison**: Water can only flow from higher or equal height to lower height
4. **Intersection**: Find cells that can reach both oceans
5. **Return Result**: Return the intersection of Pacific and Atlantic reachable cells

## Solution

- Time Complexity: `O(m*n)`
  > We visit each cell at most twice (once for each ocean)
- Space Complexity: `O(m*n)`
  > We use two boolean matrices to track reachability

```js tab="JavaScript"
/**
 * @param {number[][]} heights
 * @return {number[][]}
 */
var pacificAtlantic = function(heights) {
    if (!heights || heights.length === 0) return [];
    
    const m = heights.length;
    const n = heights[0].length;
    const pacific = Array(m).fill().map(() => Array(n).fill(false));
    const atlantic = Array(m).fill().map(() => Array(n).fill(false));
    
    const dfs = (i, j, ocean) => {
        ocean[i][j] = true;
        
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
        for (const [di, dj] of directions) {
            const ni = i + di;
            const nj = j + dj;
            
            if (ni >= 0 && ni < m && nj >= 0 && nj < n && 
                !ocean[ni][nj] && heights[ni][nj] >= heights[i][j]) {
                dfs(ni, nj, ocean);
            }
        }
    };
    
    // Pacific Ocean (left and top borders)
    for (let i = 0; i < m; i++) {
        dfs(i, 0, pacific);
    }
    for (let j = 0; j < n; j++) {
        dfs(0, j, pacific);
    }
    
    // Atlantic Ocean (right and bottom borders)
    for (let i = 0; i < m; i++) {
        dfs(i, n - 1, atlantic);
    }
    for (let j = 0; j < n; j++) {
        dfs(m - 1, j, atlantic);
    }
    
    // Find intersection
    const result = [];
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (pacific[i][j] && atlantic[i][j]) {
                result.push([i, j]);
            }
        }
    }
    
    return result;
};
```

```java tab="Java"
class Solution {
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        if (heights == null || heights.length == 0) return new ArrayList<>();
        
        int m = heights.length;
        int n = heights[0].length;
        boolean[][] pacific = new boolean[m][n];
        boolean[][] atlantic = new boolean[m][n];
        
        // Pacific Ocean (left and top borders)
        for (int i = 0; i < m; i++) {
            dfs(heights, pacific, i, 0, m, n);
        }
        for (int j = 0; j < n; j++) {
            dfs(heights, pacific, 0, j, m, n);
        }
        
        // Atlantic Ocean (right and bottom borders)
        for (int i = 0; i < m; i++) {
            dfs(heights, atlantic, i, n - 1, m, n);
        }
        for (int j = 0; j < n; j++) {
            dfs(heights, atlantic, m - 1, j, m, n);
        }
        
        // Find intersection
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (pacific[i][j] && atlantic[i][j]) {
                    result.add(Arrays.asList(i, j));
                }
            }
        }
        
        return result;
    }
    
    private void dfs(int[][] heights, boolean[][] ocean, int i, int j, int m, int n) {
        ocean[i][j] = true;
        
        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (int[] dir : directions) {
            int ni = i + dir[0];
            int nj = j + dir[1];
            
            if (ni >= 0 && ni < m && nj >= 0 && nj < n && 
                !ocean[ni][nj] && heights[ni][nj] >= heights[i][j]) {
                dfs(heights, ocean, ni, nj, m, n);
            }
        }
    }
}
```
