---
title: Balanced Binary Tree
description: Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.
difficulty: Easy
timeLimit: 15 mins
week: 1
tags:
  - Binary Tree
  - Tree
  - Depth-First Search
---

```js title="Example"
Input: root = [3, 9, 20, null, null, 15, 7]
Output: true
Explanation: The tree is height-balanced.

Input: root = [1, 2, 2, 3, 3, null, null, 4, 4]
Output: false
Explanation: The tree is not height-balanced.
```

## Approach

1. **Recursive Height Check**: Use a recursive function to check if the tree is balanced.
2. **Calculate Height**: For each node, calculate the height of left and right subtrees.
3. **Check Balance**: If the difference in heights is more than 1, return false.
4. **Return Height**: Return the height of the current subtree.
5. **Early Termination**: Return -1 if any subtree is unbalanced.

## Solution

- Time Complexity: `O(n)`
  > Where n is the number of nodes in the tree. We visit each node once.
- Space Complexity: `O(h)`
  > The recursion stack depth is at most the height of the tree.

```js tab="JavaScript"
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    return getHeight(root) !== -1;
};

const getHeight = (node) => {
    if (node === null) return 0;
    
    const leftHeight = getHeight(node.left);
    if (leftHeight === -1) return -1;
    
    const rightHeight = getHeight(node.right);
    if (rightHeight === -1) return -1;
    
    if (Math.abs(leftHeight - rightHeight) > 1) return -1;
    
    return Math.max(leftHeight, rightHeight) + 1;
};
```

```java tab="Java"
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }
    
    private int getHeight(TreeNode node) {
        if (node == null) return 0;
        
        int leftHeight = getHeight(node.left);
        if (leftHeight == -1) return -1;
        
        int rightHeight = getHeight(node.right);
        if (rightHeight == -1) return -1;
        
        if (Math.abs(leftHeight - rightHeight) > 1) return -1;
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```
