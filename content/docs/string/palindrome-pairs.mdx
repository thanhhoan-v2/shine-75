---
title: Palindrome Pairs
description: Given a list of unique words, return all the pairs of distinct indices [i, j] so that the concatenation of the two words words[i] + words[j] is a palindrome.
difficulty: Hard
timeLimit: 40 mins
week: 4
tags:
  - String
  - Hash Table
  - Trie
---

```js title="Example"
Input: words = ["abcd","dcba","lls","s","sssll"]
Output: [[0,1],[1,0],[3,2],[2,4]]
Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]

Input: words = ["bat","tab","cat"]
Output: [[0,1],[1,0]]
```

## Approach

1. **Hash Map**: Use a hash map to store all words and their indices for quick lookup.
2. **Case Analysis**: For each word, check different cases where concatenation could form a palindrome.
3. **Prefix/Suffix Check**: For each word, check if its prefix or suffix can form a palindrome with another word.
4. **Empty String**: Handle the special case of empty strings.
5. **Optimization**: Avoid duplicate pairs and check for valid concatenations efficiently.

## Solution

- Time Complexity: `O(n * kÂ²)`
  > Where n is the number of words and k is the maximum length of any word. For each word, we check all possible prefixes and suffixes.
- Space Complexity: `O(n * k)`
  > We store all words in a hash map.

```js tab="JavaScript"
/**
 * @param {string[]} words
 * @return {number[][]}
 */
var palindromePairs = function(words) {
    const result = [];
    const wordMap = new Map();
    
    // Store all words and their indices
    for (let i = 0; i < words.length; i++) {
        wordMap.set(words[i], i);
    }
    
    for (let i = 0; i < words.length; i++) {
        const word = words[i];
        const n = word.length;
        
        // Check all possible prefixes and suffixes
        for (let j = 0; j <= n; j++) {
            // Check if prefix is palindrome
            if (isPalindrome(word, 0, j - 1)) {
                const suffix = word.substring(j);
                const reversedSuffix = reverseString(suffix);
                
                if (wordMap.has(reversedSuffix) && wordMap.get(reversedSuffix) !== i) {
                    result.push([wordMap.get(reversedSuffix), i]);
                }
            }
            
            // Check if suffix is palindrome
            if (isPalindrome(word, j, n - 1)) {
                const prefix = word.substring(0, j);
                const reversedPrefix = reverseString(prefix);
                
                if (wordMap.has(reversedPrefix) && wordMap.get(reversedPrefix) !== i) {
                    result.push([i, wordMap.get(reversedPrefix)]);
                }
            }
        }
    }
    
    return result;
};

// Helper function to check if substring is palindrome
function isPalindrome(s, start, end) {
    while (start < end) {
        if (s[start] !== s[end]) return false;
        start++;
        end--;
    }
    return true;
}

// Helper function to reverse string
function reverseString(s) {
    return s.split('').reverse().join('');
}
```

```java tab="Java"
class Solution {
    public List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> result = new ArrayList<>();
        Map<String, Integer> wordMap = new HashMap<>();
        
        // Store all words and their indices
        for (int i = 0; i < words.length; i++) {
            wordMap.put(words[i], i);
        }
        
        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            int n = word.length();
            
            // Check all possible prefixes and suffixes
            for (int j = 0; j <= n; j++) {
                // Check if prefix is palindrome
                if (isPalindrome(word, 0, j - 1)) {
                    String suffix = word.substring(j);
                    String reversedSuffix = new StringBuilder(suffix).reverse().toString();
                    
                    if (wordMap.containsKey(reversedSuffix) && wordMap.get(reversedSuffix) != i) {
                        result.add(Arrays.asList(wordMap.get(reversedSuffix), i));
                    }
                }
                
                // Check if suffix is palindrome
                if (isPalindrome(word, j, n - 1)) {
                    String prefix = word.substring(0, j);
                    String reversedPrefix = new StringBuilder(prefix).reverse().toString();
                    
                    if (wordMap.containsKey(reversedPrefix) && wordMap.get(reversedPrefix) != i) {
                        result.add(Arrays.asList(i, wordMap.get(reversedPrefix)));
                    }
                }
            }
        }
        
        return result;
    }
    
    // Helper function to check if substring is palindrome
    private boolean isPalindrome(String s, int start, int end) {
        while (start < end) {
            if (s.charAt(start) != s.charAt(end)) return false;
            start++;
            end--;
        }
        return true;
    }
}
```
