---
title: Two Sum
description: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.
difficulty: Easy
timeLimit: 15 mins
tags:
  - Array
  - Hash Table
  - Two Pointers
---

```js title="Example"
twoSum([2, 7, 11, 15], 9); // [0, 1]
twoSum([3, 2, 4], 6); // [1, 2]
twoSum([3, 3], 6); // [0, 1]
```

## Approach

- Initialize an empty hash map to store `{current_num: index}` pairs
- For each element in the array:
  - Calculate its complement (what number we need to reach the target)
  - Check if the complement exists in our map
    - If found: return `[complement_index, current_index]`
    - If not found: store `current_num: current_index` in the map
- Return empty array if no solution exists

## Solution

- Time Complexity: `O(n)`
  - We iterate through the array once, so the time complexity is `O(n)`
- Space Complexity: `O(n)`
  - We use a hash map to store the numbers and their indices, so the space complexity is `O(n)`

```js title="JavaScript"
const twoSum = (nums, target) => {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    map.set(nums[i], i);
  }
};
```

```java title="Java"
class TwoSum {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        return null;
    }
}
```