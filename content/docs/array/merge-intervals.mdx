---
title: Merge Intervals
description: Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
difficulty: Medium
timeLimit: 25 mins
tags:
  - Array
  - Sorting
---

```js title="Example"
merge([[1, 3], [2, 6], [8, 10], [15, 18]]); // [[1, 6], [8, 10], [15, 18]]
merge([[1, 4], [4, 5]]); // [[1, 5]]
merge([[1, 4], [0, 4]]); // [[0, 4]]
```

## Approach

- Sort the intervals by start time
- Initialize result with the first interval
- For each subsequent interval:
  - If it overlaps with the last interval in result, merge them
  - If it doesn't overlap, add it to result
- Return the merged intervals

## Solution

- Time Complexity: `O(n log n)`
  - We need to sort the intervals, which takes O(n log n)
- Space Complexity: `O(n)`
  - We create a new array to store the result

```js tab="JavaScript"
const merge = (intervals) => {
  if (intervals.length === 0) return [];
  
  intervals.sort((a, b) => a[0] - b[0]);
  const result = [intervals[0]];
  
  for (let i = 1; i < intervals.length; i++) {
    const current = intervals[i];
    const last = result[result.length - 1];
    
    if (current[0] <= last[1]) {
      last[1] = Math.max(last[1], current[1]);
    } else {
      result.push(current);
    }
  }
  
  return result;
};
```

```java tab="Java"
public int[][] merge(int[][] intervals) {
    if (intervals.length == 0) return new int[0][0];
    
    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
    List<int[]> result = new ArrayList<>();
    result.add(intervals[0]);
    
    for (int i = 1; i < intervals.length; i++) {
        int[] current = intervals[i];
        int[] last = result.get(result.size() - 1);
        
        if (current[0] <= last[1]) {
            last[1] = Math.max(last[1], current[1]);
        } else {
            result.add(current);
        }
    }
    
    return result.toArray(new int[result.size()][]);
}
```
