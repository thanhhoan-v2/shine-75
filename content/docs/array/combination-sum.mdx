---
title: Combination Sum
description: Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times.
difficulty: Medium
timeLimit: 30 mins
tags:
  - Array
  - Backtracking
  - Recursion
---

```js title="Example"
combinationSum([2, 3, 6, 7], 7); // [[2,2,3], [7]]
combinationSum([2, 3, 5], 8); // [[2,2,2,2], [2,3,3], [3,5]]
combinationSum([2], 1); // []
```

## Approach

- Use backtracking to explore all possible combinations
- Sort the candidates array to avoid duplicate combinations
- For each candidate, try using it multiple times (since same number can be chosen unlimited times)
- Use a recursive function with current combination, remaining target, and start index
- Add valid combinations to the result when target becomes 0

## Solution

- Time Complexity: `O(k * 2^n)`
  - Where k is the average length of combinations and n is the number of candidates
  - In worst case, we explore all possible combinations
- Space Complexity: `O(k * n)`
  - Space for the recursion stack and storing combinations

```js tab="JavaScript"
const combinationSum = (candidates, target) => {
  const result = [];
  
  const backtrack = (start, target, combination) => {
    if (target === 0) {
      result.push([...combination]);
      return;
    }
    
    if (target < 0) return;
    
    for (let i = start; i < candidates.length; i++) {
      combination.push(candidates[i]);
      backtrack(i, target - candidates[i], combination);
      combination.pop();
    }
  };
  
  candidates.sort((a, b) => a - b);
  backtrack(0, target, []);
  return result;
};
```

```java tab="Java"
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(candidates);
    backtrack(result, new ArrayList<>(), candidates, target, 0);
    return result;
}

private void backtrack(List<List<Integer>> result, List<Integer> combination, 
                     int[] candidates, int target, int start) {
    if (target == 0) {
        result.add(new ArrayList<>(combination));
        return;
    }
    
    if (target < 0) return;
    
    for (int i = start; i < candidates.length; i++) {
        combination.add(candidates[i]);
        backtrack(result, combination, candidates, target - candidates[i], i);
        combination.remove(combination.size() - 1);
    }
}
```
